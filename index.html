<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minimal TV Player</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      width: 100vw;
      overflow-x: hidden;
    }
    body {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    #sidebar {
      width: 250px;
      background: #222;
      color: #fff;
      overflow-y: auto;
      height: 100vh;
      flex-shrink: 0;
    }
    #sidebar h2 {
      text-align: center;
      margin: 10px 0;
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
    }
    #episodeList {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #episodeList li {
      padding: 10px 15px;
      cursor: pointer;
      border-bottom: 1px solid #333;
    }
    #episodeList li.active {
      background: #555;
      font-weight: bold;
    }
    #episodeList li:hover {
      background: #444;
    }
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: center;
      background: #111;
      height: 100vh;
      min-width: 0;
    }
    #videoWrapper {
      width: 100%;
      aspect-ratio: 16/9;
      background: black;
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      min-height: 0;
    }
    video {
      width: 100%;
      height: 100%;
      background: black;
      outline: none;
      object-fit: contain;
      display: block;
    }
    #controls {
      text-align: center;
      margin: 10px 0;
    }
    button {
      background: #333;
      border: none;
      color: white;
      padding: 10px 15px;
      margin: 0 5px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 4px;
      user-select: none;
    }
    button:hover {
      background: #555;
    }
    @media (max-width: 800px) {
      body {
        flex-direction: column;
      }
      #sidebar {
        width: 100vw;
        height: auto;
        max-height: 200px;
      }
      #main {
        height: auto;
      }
      #videoWrapper {
        aspect-ratio: 16/9;
        min-height: 180px;
        max-height: 50vh;
      }
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>Episodes</h2>
    <div id="globalProgress" style="margin: 10px 15px 10px 15px;"></div>
    <ul id="episodeList"></ul>
  </div>
  <div id="main">
    <div id="videoWrapper">
      <video id="player" controls preload="auto"></video>
    </div>
    <div id="controls">
  <button onclick="nextEpisode()">‚è≠ Next Episode</button>
  <button onclick="skipOpening()">‚è© Skip Opening</button>
  <button onclick="watchFromBeginning()">üîÑ Watch from Beginning</button>
    </div>
  </div>
  <script>
    const player = document.getElementById('player');
    const episodeListEl = document.getElementById('episodeList');
    let episodes = [];
    let currentIndex = 0;
    let episodeTree = {};

    // --- Helpers for watched/resume state ---
    function getWatchedSet() {
      return new Set(JSON.parse(localStorage.getItem('watchedEpisodes') || '[]'));
    }
    function setWatchedSet(set) {
      localStorage.setItem('watchedEpisodes', JSON.stringify([...set]));
    }
    function getResumeTimes() {
      return JSON.parse(localStorage.getItem('resumeTimes') || '{}');
    }
    function setResumeTimes(obj) {
      localStorage.setItem('resumeTimes', JSON.stringify(obj));
    }


    // --- Subtitle loader ---
    function removeAllTracks() {
      // Only remove <track> elements, not all children
      const tracks = player.querySelectorAll('track');
      tracks.forEach(track => track.remove());
    }

    function tryLoadSubtitleForEpisode(epPath, callback) {
      const base = epPath.replace(/\.[^/.]+$/, "");
      const srtUrl = base + ".srt";
      console.log("epPath:", epPath, "srtUrl:", srtUrl);
      fetch(srtUrl)
        .then(res => {
          if (res.ok) {
            return res.text();
          }
          throw new Error("No subtitle found");
        })
        .then(srtText => {
          const vtt = srt2vtt(srtText, -0.25);
          const vttBlob = new Blob([vtt], { type: "text/vtt" });
          const vttUrl = URL.createObjectURL(vttBlob);
          const track = document.createElement('track');
          track.kind = "subtitles";
          track.label = "English";
          track.srclang = "en";
          track.src = vttUrl;
          track.default = true;
          player.appendChild(track);
          if (callback) callback(true);
        })
        .catch(() => {
          if (callback) callback(false);
        });
    }

    // Simple SRT to VTT converter (client-side)
    function srt2vtt(srt, offsetSeconds = -0.25) {
      // Remove BOM if present
      srt = srt.replace(/^\uFEFF/, '');
      // Normalize line endings
      srt = srt.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      // Split into lines
      const lines = srt.split('\n');
      const vttLines = ['WEBVTT\n'];
  const timeRe = /^(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*\-\-\>\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})(.*)$/;
      for (let i = 0; i < lines.length; i++) {
        const m = lines[i].match(timeRe);
        if (m) {
          // Parse start and end times
          function toMs(h, m, s, ms) {
            return (
              parseInt(h) * 3600000 +
              parseInt(m) * 60000 +
              parseInt(s) * 1000 +
              parseInt(ms)
            );
          }
          function toVtt(ts) {
            let ms = Math.max(0, ts); // Prevent negative times
            const h = Math.floor(ms / 3600000);
            ms %= 3600000;
            const m = Math.floor(ms / 60000);
            ms %= 60000;
            const s = Math.floor(ms / 1000);
            ms %= 1000;
            return (
              String(h).padStart(2, '0') +
              ':' +
              String(m).padStart(2, '0') +
              ':' +
              String(s).padStart(2, '0') +
              '.' +
              String(ms).padStart(3, '0')
            );
          }
          const startMs =
            toMs(m[1], m[2], m[3], m[4]) + offsetSeconds * 1000;
          const endMs =
            toMs(m[5], m[6], m[7], m[8]) + offsetSeconds * 1000;
          vttLines.push(
            toVtt(startMs) + ' --> ' + toVtt(endMs) + (m[9] || '')
          );
        } else {
          vttLines.push(lines[i]);
        }
      }
      return vttLines.join('\n').replace(/\n{3,}/g, '\n\n').trim();
    }

    // --- Build episode tree for folders ---
    function buildTree(paths) {
      // Each node: { files: [], dirs: {}, watched: 0, total: 0 }
      const root = { files: [], dirs: {}, watched: 0, total: 0 };
      for (const path of paths) {
        const parts = path.split('/');
        let node = root;
        for (let i = 0; i < parts.length; ++i) {
          const part = parts[i];
          if (i === parts.length - 1) {
            node.files = node.files || [];
            node.files.push(path);
          } else {
            node.dirs = node.dirs || {};
            node.dirs[part] = node.dirs[part] || { files: [], dirs: {}, watched: 0, total: 0 };
            node = node.dirs[part];
          }
        }
      }
      return root;
    }

    // Recursively count watched/total for each node
    function countWatched(node, watchedSet) {
      let watched = 0, total = 0;
      if (node.files) {
        total += node.files.length;
        for (const ep of node.files) {
          if (watchedSet.has(ep)) watched++;
        }
      }
      if (node.dirs) {
        for (const dir in node.dirs) {
          const res = countWatched(node.dirs[dir], watchedSet);
          watched += res.watched;
          total += res.total;
        }
      }
      node.watched = watched;
      node.total = total;
      return { watched, total };
    }

    // --- Render episode tree with dropdowns ---
    function renderProgressBar(watched, total) {
      const percent = total === 0 ? 0 : Math.round((watched / total) * 100);
      const bar = document.createElement('div');
      bar.style.position = 'relative';
      bar.style.height = '10px';
      bar.style.background = '#333';
      bar.style.borderRadius = '5px';
      bar.style.margin = '4px 0 8px 0';
      bar.style.overflow = 'hidden';
      const fill = document.createElement('div');
      fill.style.height = '100%';
      fill.style.width = percent + '%';
      fill.style.background = percent === 100 ? 'limegreen' : '#8888ff';
      fill.style.transition = 'width 0.3s';
      bar.appendChild(fill);
      const label = document.createElement('span');
      label.textContent = `${watched}/${total}`;
      label.style.position = 'absolute';
      label.style.left = '50%';
      label.style.top = '-18px';
      label.style.transform = 'translateX(-50%)';
      label.style.fontSize = '12px';
      label.style.color = '#ccc';
      bar.appendChild(label);
      return bar;
    }

    function renderTree(node, parentUl, prefix = '') {
      // Render subfolders first
      if (node.dirs) {
        for (const dir in node.dirs) {
          const folderLi = document.createElement('li');
          folderLi.style.fontWeight = 'bold';
          folderLi.style.cursor = 'pointer';
          folderLi.textContent = 'üìÅ ' + dir;
          // Progress bar for this folder
          const progress = renderProgressBar(node.dirs[dir].watched, node.dirs[dir].total);
          folderLi.appendChild(progress);
          // Dropdown
          const subUl = document.createElement('ul');
          subUl.style.display = 'none';
          subUl.style.listStyle = 'none';
          subUl.style.paddingLeft = '18px';
          folderLi.onclick = function(e) {
            e.stopPropagation();
            subUl.style.display = subUl.style.display === 'none' ? 'block' : 'none';
          };
          folderLi.appendChild(subUl);
          parentUl.appendChild(folderLi);
          renderTree(node.dirs[dir], subUl, prefix + dir + '/');
        }
      }
      // Render files
      if (node.files) {
        node.files.forEach((ep, i) => {
          const li = document.createElement('li');
          li.textContent = ep.split('/').pop();
          li.title = ep;
          li.onclick = () => loadEpisode(episodes.indexOf(ep));
          // Watched state
          if (getWatchedSet().has(ep)) li.style.color = 'limegreen';
          if (episodes.indexOf(ep) === currentIndex) li.classList.add('active');
          parentUl.appendChild(li);
        });
      }
    }

    function buildEpisodeList() {
      episodeListEl.innerHTML = '';
      episodeTree = buildTree(episodes);
      const watchedSet = getWatchedSet();
      countWatched(episodeTree, watchedSet);
      // Global progress bar
      const globalProgress = document.getElementById('globalProgress');
      globalProgress.innerHTML = '';
      globalProgress.appendChild(renderProgressBar(episodeTree.watched, episodeTree.total));
      renderTree(episodeTree, episodeListEl);
      updateEpisodeStyles();
    }

    function updateEpisodeStyles() {
      // Update watched and active states
      const watched = getWatchedSet();
      let idx = 0;
      function updateLis(ul) {
        for (const li of ul.children) {
          if (li.querySelector('ul')) {
            // Folder
            updateLis(li.querySelector('ul'));
          } else {
            const ep = episodes[idx++];
            // Reset styles
            li.classList.toggle('active', idx - 1 === currentIndex);
            if (idx - 1 === currentIndex) {
              li.style.color = 'yellow'; // Currently playing
            } else if (watched.has(ep)) {
              li.style.color = 'limegreen'; // Watched
            } else {
              li.style.color = ''; // Default
            }
          }
        }
      }
      updateLis(episodeListEl);
    }

    function loadEpisode(index, fromBeginning = false) {
      if (index < 0 || index >= episodes.length) return;
      currentIndex = index;
      removeAllTracks();
      player.src = episodes[currentIndex];
      tryLoadSubtitleForEpisode(episodes[currentIndex], () => {
        player.load();
        player.onloadedmetadata = () => {
          // Resume time
          const resumeTimes = getResumeTimes();
          if (!fromBeginning && resumeTimes[episodes[currentIndex]]) {
            player.currentTime = resumeTimes[episodes[currentIndex]];
          } else {
            player.currentTime = 0;
          }
          // Force showing subtitles
          for (const t of player.textTracks) {
            t.mode = 'showing';
          }
        };
        updateEpisodeStyles();
      });
    }

    function nextEpisode() {
      if (currentIndex + 1 < episodes.length) {
        loadEpisode(currentIndex + 1);
        player.play();
      }
    }

    function skipOpening() {
      player.currentTime += 90;
    }

    function watchFromBeginning() {
      loadEpisode(currentIndex, true);
      player.play();
    }

    // Remove chooseSubtitle and chooseAudio functions
    // Apply preferred subtitle/audio on video load
    player.addEventListener('loadedmetadata', () => {
      // No-op: subtitles are auto-loaded if available
    });

    // Save watched and resume time
    player.addEventListener('ended', () => {
      const watched = getWatchedSet();
      watched.add(episodes[currentIndex]);
      setWatchedSet(watched);
      updateEpisodeStyles();
      nextEpisode();
    });
    player.addEventListener('timeupdate', () => {
      if (player.duration > 0 && !player.paused) {
        const resumeTimes = getResumeTimes();
        resumeTimes[episodes[currentIndex]] = player.currentTime;
        setResumeTimes(resumeTimes);
      }
    });
    player.addEventListener('play', () => {
      // If user seeks to end, mark as watched
      if (player.currentTime >= player.duration - 5) {
        const watched = getWatchedSet();
        watched.add(episodes[currentIndex]);
        setWatchedSet(watched);
        updateEpisodeStyles();
      }
    });

    fetch('episodes.json')
      .then(res => res.json())
      .then(data => {
        episodes = data;
        buildEpisodeList();
        loadEpisode(0);
      });
  </script>
</body>
</html>
